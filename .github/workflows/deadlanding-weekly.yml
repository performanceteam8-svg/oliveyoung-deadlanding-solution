# 데드랜딩 점검: 매주 월·목 6시(KST) 실행, 9시(KST) Slack 알림
# 수동 실행: Actions → "데드랜딩 주간 점검" → Run workflow (점검만 실행, Slack은 9시 스케줄 시 전송)

name: 데드랜딩 주간 점검

on:
  schedule:
    # 6시 KST 점검: 월·목 06:00 KST = 일 21:00 UTC, 수 21:00 UTC
    - cron: '0 21 * * 0'
    - cron: '0 21 * * 3'
    # 9시 KST 알림: 월·목 09:00 KST = 월 00:00 UTC, 목 00:00 UTC
    - cron: '0 0 * * 1'
    - cron: '0 0 * * 4'
  workflow_dispatch:
    inputs:
      notify_only:
        description: 'Slack 알림만 전송 (캐시 있으면 그대로, 없으면 fallback 메시지)'
        required: false
        default: false
        type: boolean

jobs:
  # 월·목 6시 KST (및 수동 실행): 점검만 수행, 결과를 캐시에 저장
  check:
    runs-on: ubuntu-latest
    if: ${{ !inputs.notify_only && (github.event_name != 'schedule' || github.event.schedule == '0 21 * * 0' || github.event.schedule == '0 21 * * 3') }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set KST date
        id: kst_date
        run: echo "date=$(TZ=Asia/Seoul date +%Y-%m-%d)" >> $GITHUB_OUTPUT

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Create credentials file
        env:
          CREDENTIALS_JSON: ${{ secrets.CREDENTIALS_JSON }}
        run: |
          mkdir -p credentials
          echo "$CREDENTIALS_JSON" > credentials/service_account.json

      - name: Run Step1 (URL 수집)
        run: python deadlanding_step1_collect_urls.py 2>&1 | tee step1.log

      - name: Run Step2 (URL 점검 및 시트 반영)
        run: python deadlanding_step2_check_and_fill.py 2>&1 | tee step2.log

      - name: Write summary for cache
        if: always()
        run: |
          mkdir -p summary
          tail -25 step2.log 2>/dev/null || tail -25 step1.log > summary/body.txt
        continue-on-error: true

      - name: Set status for 9am Slack
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then echo "success" > summary/status.txt; else echo "failure" > summary/status.txt; fi

      - name: Save result to cache (for 9am Slack)
        if: always()
        uses: actions/cache/save@v4
        with:
          path: summary
          key: deadlanding-result-${{ steps.kst_date.outputs.date }}
        continue-on-error: true

  # 월·목 9시 KST: 캐시에서 당일 점검 결과 복원 후 Slack 전송 (수동 시 notify_only=true 로 알림만 테스트 가능)
  notify:
    runs-on: ubuntu-latest
    if: ${{ (github.event_name == 'workflow_dispatch' && inputs.notify_only == true) || (github.event_name == 'schedule' && (github.event.schedule == '0 0 * * 1' || github.event.schedule == '0 0 * * 4')) }}
    steps:
      - name: Set KST date
        id: kst_date
        run: echo "date=$(TZ=Asia/Seoul date +%Y-%m-%d)" >> $GITHUB_OUTPUT

      - name: Restore cached result
        id: cache
        uses: actions/cache/restore@v4
        with:
          path: summary
          key: deadlanding-result-${{ steps.kst_date.outputs.date }}

      # Slack: 표시 이름 "데드랜딩 점검 결과", 성공/실패 본문, 결과 보기 버튼 (Variables에서 SPREADSHEET_URL 지정 가능)
      - name: Slack notification (9am KST)
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_USERNAME: ${{ vars.SLACK_USERNAME || '데드랜딩 점검 결과' }}
          SLACK_BODY_SUCCESS: ${{ vars.SLACK_BODY_SUCCESS || '데드랜딩 점검에 성공했습니다. 결과를 확인해주세요.' }}
          SLACK_BODY_FAILURE: ${{ vars.SLACK_BODY_FAILURE || '데드랜딩 점검에 실패했습니다. 원인을 확인해주세요.' }}
          SLACK_FALLBACK_MSG: ${{ vars.SLACK_FALLBACK_MSG || '오늘 오전 6시 점검 결과가 없습니다. 시트에서 확인해주세요.' }}
          SPREADSHEET_URL: ${{ vars.SPREADSHEET_URL || 'https://docs.google.com/spreadsheets/d/12gg9I032qYNdcE_a0d7RB02eguhLKU7mxiAEkJ47RcU/edit' }}
        run: |
          # URL 앞뒤 공백·줄바꿈 제거 (exit code 3 = URL malformed 방지)
          SLACK_WEBHOOK_URL="$(echo "$SLACK_WEBHOOK_URL" | tr -d '\n\r' | xargs)"
          if [ -z "$SLACK_WEBHOOK_URL" ]; then echo "SLACK_WEBHOOK_URL 비어 있음, 건너뜀"; exit 0; fi
          if [ -f summary/body.txt ]; then
            SUMMARY=$(cat summary/body.txt)
            if [ -f summary/status.txt ] && [ "$(cat summary/status.txt)" = "failure" ]; then
              BODY_TEXT="❌ $SLACK_BODY_FAILURE"
            else
              BODY_TEXT="✅ $SLACK_BODY_SUCCESS"
            fi
          else
            BODY_TEXT="📋 $SLACK_FALLBACK_MSG"
            SUMMARY=""
          fi
          # Slack 블록 텍스트 제한(3000자) 방지를 위해 로그 요약 길이 제한
          SUMMARY="${SUMMARY:0:2500}"
          PAYLOAD=$(jq -n \
            --arg user "$SLACK_USERNAME" \
            --arg body "$BODY_TEXT" \
            --arg url "$SPREADSHEET_URL" \
            --arg sum "$SUMMARY" \
            '{username: $user, blocks: [
              {type: "section", text: {type: "mrkdwn", text: $body}},
              (if $sum != "" then {type: "section", text: {type: "mrkdwn", text: ("```\n" + $sum + "\n```")}} else empty end),
              {type: "actions", elements: [{type: "button", text: {type: "plain_text", text: "결과 보기"}, url: $url}]}
            ]}')
          HTTP_CODE=$(curl -sS -w '%{http_code}' -o /tmp/slack_resp -X POST "$SLACK_WEBHOOK_URL" -H 'Content-Type: application/json' -d "$PAYLOAD") || true
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Slack 전송 실패. HTTP code: $HTTP_CODE"
            echo "Slack 응답: $(cat /tmp/slack_resp 2>/dev/null || echo '없음')"
            exit 1
          fi
          echo "Slack 전송 완료 (HTTP $HTTP_CODE)"
